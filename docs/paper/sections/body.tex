
\subsection{\texttt{fix arbfn}} \label{arbfn}

% Description
The first fix provided by the package is \texttt{fix arbfn}. It
is the most powerful and the slowest. Every time this fix is
called, its atoms are sent off to the controller over MPI. The
controller then determines some amount of force to add to each
atom, sending it back to LAMMPS to implement. The controller is
also allowed to send a ``waiting'' packet indicating that LAMMPS
should wait another few milliseconds. If no response is received
within some specified time limit, LAMMPS will error. Since there
may be arbitrarily many LAMMPS instances running, the controller
may choose to await all the data or to send back data
immediately. It is slightly faster to send back data one
controller at a time, but limits the capabilities of the fix
(for instance, a fix pushing atoms towards the center of mass
could not be implemented).

% Use case
This fix can be used to implement frame-by-frame control of the
forces of atoms based on the state of some external system. As
a frivolous example, imagine a LAMMPS simulation where forces
could be applied by using a physical joystick. It can also be
used to apply forces based on attributes not feasibly
implementable solely within LAMMPS.

% Protocol
The protocol for \texttt{fix arbfn} is shown in figure
\ref{fig:arbfn_protocol}. Note that communication between LAMMPS
and the ``worker'' (fix object instance) is virtually free,
while communication between the worker and the controller is
very expensive.

\begin{figure}
    \centering
    \includegraphics[width=0.5\textwidth]{arbfn_protocol}
    \caption{\texttt{fix arbfn} protocol.}
    \label{fig:arbfn_protocol}
\end{figure}

% Evaluation
While necessary for some use cases, this fix is painfully slow:
A simulation that may take only a few minutes without it will
instead take hours.

\subsection{\texttt{fix arbfn/ffield}} \label{ffield}

% Description
Evolving from the aforementioned MPI delays is the
\texttt{arbfn/ffield} fix. This takes in some spatial grid of
nodes at instantiation via MPI, then interpolates between them
to find specific force field values.

% Use case
This fix is \emph{not} able to update frame-by-frame, and the
interpolation it does is position-only (velocity, existing
force, and orientation cannot come into play), but is in
exchange about 100 times faster.

% Protocol
The protocol for the \texttt{arbfn/ffield} fix is shown in
figure \ref{fig:ffield_protocol}. Note that there are no longer
costly MPI calls within the simulation loop, and thus the
simulation will perform much better.

\begin{figure}
    \centering
    \includegraphics[width=0.5\textwidth]{ffield_protocol}
    \caption{\texttt{fix arbfn/ffield} protocol.}
    \label{fig:ffield_protocol}
\end{figure}

% Evaluation
Although the difference between figures \ref{fig:arbfn_protocol}
and \ref{fig:ffield_protocol} may seem trivial, the omission of
the controller from the simulation loop allows
\ref{fig:ffield_protocol} to run orders of magnitude faster.

\subsection{\texttt{fix arbfn/ffield} with \texttt{every n}}
    \label{ffield_every}

% Description
Our final protocol addresses the holes in what
\texttt{fix arbfn/ffield} can compute. Instead of receiving a
single interpolation grid at the beginning and using it for the
entire simulation, the \texttt{every n} argument allows us to
dynamically update the grid every $n$ time steps. Specifically,
every $n$-th time step, the worker sends all of its atomic data
to the controller and receives a new interpolation grid in
return.

% Use case
This protocol allows more generality at the cost of speed, while
still being (generally) faster than \ref{arbfn}. It allows a
degree of dependency of the force field on the atomic data (e.g.
center of mass) which was previously impossible.

% Protocol
The protocol for \texttt{fix arbfn/ffield} with the
\texttt{every n} argument is shown in figure
\ref{fig:ffield_every_protocol}. Note that this reintroduces the
costly IPC during the simulation, but is still more sparse than
\ref{arbfn}.

\begin{figure}
    \centering
    \includegraphics[width=0.5\textwidth]{ffield_every_protocol}
    \caption{\texttt{fix arbfn/ffield} protocol when used with
        the \texttt{every n} argument.}
    \label{fig:ffield_every_protocol}
\end{figure}

% Evaluation
\ref{ffield} is a special case of \ref{ffield_every} where $n$
is larger than the length of the simulation. Internally, this is
represented by \texttt{every 0}. The other limit case,
\texttt{every 1}, is \emph{nearly} \ref{arbfn}: It communicates
every frame (and therefore is at least as slow), but the atom
forces are ultimately still interpolated according to the grid,
rather than directly controlled.

\subsection{Running Simulations}

In order to keep ARBFN MPI communication from interfering with
internal LAMMPS communication, we must run LAMMPS with the
\texttt{-mpicolor ...} command-line argument. The number
following this must be anything \textbf{except $56789$} (this
color is reserved for internal package communication). On UNIX
systems, this takes the form that follows.

\begin{verbatim}
mpirun -n 1 ./controller : \
    -n ${num_lmp_threads} \
    lmp -mpicolor 123 \
    -in input_script.lmp
\end{verbatim}
